
@article{oneil_log-structured_1996,
	title = {The log-structured merge-tree ({LSM}-tree)},
	volume = {33},
	issn = {0001-5903, 1432-0525},
	url = {http://link.springer.com/10.1007/s002360050048},
	doi = {10.1007/s002360050048},
	language = {en},
	number = {4},
	urldate = {2023-12-27},
	journal = {Acta Informatica},
	author = {O’Neil, Patrick and Cheng, Edward and Gawlick, Dieter and O’Neil, Elizabeth},
	month = jun,
	year = {1996},
	keywords = {to read},
	pages = {351--385},
	file = {Available Version (via Google Scholar):/home/wilson/Zotero/storage/SWD3ZP29/O’Neil et al. - 1996 - The log-structured merge-tree (LSM-tree).pdf:application/pdf},
}

@article{luo_lsm-based_2020,
	title = {{LSM}-based storage techniques: a survey},
	volume = {29},
	issn = {0949-877X},
	shorttitle = {{LSM}-based storage techniques},
	url = {https://doi.org/10.1007/s00778-019-00555-y},
	doi = {10.1007/s00778-019-00555-y},
	abstract = {Recently, the log-structured merge-tree (LSM-tree) has been widely adopted for use in the storage layer of modern NoSQL systems. Because of this, there have been a large number of research efforts, from both the database community and the operating systems community, that try to improve various aspects of LSM-trees. In this paper, we provide a survey of recent research efforts on LSM-trees so that readers can learn the state of the art in LSM-based storage techniques. We provide a general taxonomy to classify the literature of LSM-trees, survey the efforts in detail, and discuss their strengths and trade-offs. We further survey several representative LSM-based open-source NoSQL systems and discuss some potential future research directions resulting from the survey.},
	language = {en},
	number = {1},
	urldate = {2024-01-22},
	journal = {The VLDB Journal},
	author = {Luo, Chen and Carey, Michael J.},
	month = jan,
	year = {2020},
	keywords = {Indexing, LSM-tree, NoSQL, Storage management},
	pages = {393--418},
	file = {Submitted Version:/home/wilson/Zotero/storage/ZQH7GFII/Luo and Carey - 2020 - LSM-based storage techniques a survey.pdf:application/pdf},
}

@article{burton_h_bloom_spacetime_1970,
	title = {Space/time trade-offs in hash coding with allowable errors},
	volume = {13},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/362686.362692},
	doi = {10.1145/362686.362692},
	abstract = {In this paper trade-offs among certain computational factors in hash coding are analyzed. The paradigm problem considered is that of testing a series of messages one-by-one for membership in a given set of messages. Two new hash-coding methods are examined and compared with a particular conventional hash-coding method. The computational factors considered are the size of the hash area (space), the time required to identify a message as a nonmember of the given set (reject time), and an allowable error frequency. The new methods are intended to reduce the amount of space required to contain the hash-coded information from that associated with conventional methods. The reduction in space is accomplished by exploiting the possibility that a small fraction of errors of commission may be tolerable in some applications, in particular, applications in which a large amount of data is involved and a core resident hash area is consequently not feasible using conventional methods. In such applications, it is envisaged that overall performance could be improved by using a smaller core resident hash area in conjunction with the new methods and, when necessary, by using some secondary and perhaps time-consuming test to “catch” the small fraction of errors associated with the new methods. An example is discussed which illustrates possible areas of application for the new methods. Analysis of the paradigm problem demonstrates that allowing a small number of test messages to be falsely identified as members of the given set will permit a much smaller hash area to be used without increasing reject time.},
	number = {7},
	urldate = {2024-01-22},
	journal = {Communications of the ACM},
	author = {{Burton H. Bloom}},
	year = {1970},
	keywords = {hash addressing, hash coding, retrieval efficiency, retrieval trade-offs, scatter storage, searching, storage efficiency, storage layout},
	pages = {422--426},
	file = {Full Text PDF:/home/wilson/Zotero/storage/FN7D3NMD/Bloom - 1970 - Spacetime trade-offs in hash coding with allowabl.pdf:application/pdf},
}

@article{pugh_skip_1990,
	title = {Skip lists: a probabilistic alternative to balanced trees},
	volume = {33},
	issn = {0001-0782},
	shorttitle = {Skip lists},
	url = {https://dl.acm.org/doi/10.1145/78973.78977},
	doi = {10.1145/78973.78977},
	abstract = {Skip lists are data structures that use probabilistic balancing rather than strictly enforced balancing. As a result, the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.},
	number = {6},
	urldate = {2024-03-11},
	journal = {Communications of the ACM},
	author = {Pugh, William},
	year = {1990},
	keywords = {data structures, searching, trees},
	pages = {668--676},
	file = {Submitted Version:/home/wilson/Zotero/storage/X8IYKZC7/Pugh - 1990 - Skip lists a probabilistic alternative to balance.pdf:application/pdf;Submitted Version:/home/wilson/Zotero/storage/TWP4CYG4/Pugh - 1990 - Skip lists a probabilistic alternative to balance.pdf:application/pdf},
}

@article{le_correct_nodate,
	title = {Correct and {Efﬁcient} {Work}-{Stealing} for {Weak} {Memory} {Models}},
	abstract = {Chase and Lev’s concurrent deque is a key data structure in sharedmemory parallel programming and plays an essential role in workstealing schedulers. We provide the ﬁrst correctness proof of an optimized implementation of Chase and Lev’s deque on top of the POWER and ARM architectures: these provide very relaxed memory models, which we exploit to improve performance but considerably complicate the reasoning. We also study an optimized x86 and a portable C11 implementation, conducting systematic experiments to evaluate the impact of memory barrier optimizations. Our results demonstrate the beneﬁts of hand tuning the deque code when running on top of relaxed memory models.},
	language = {en},
	author = {Lê, Nhat Minh and Pop, Antoniu and Cohen, Albert and Nardelli, Francesco Zappa},
	file = {Lê et al. - Correct and Efﬁcient Work-Stealing for Weak Memory.pdf:/home/wilson/Zotero/storage/ZUCLG2AJ/Lê et al. - Correct and Efﬁcient Work-Stealing for Weak Memory.pdf:application/pdf},
}

@article{desnoyers_user-level_2011,
	title = {User-level implementations of read-copy update},
	volume = {23},
	url = {https://ieeexplore.ieee.org/abstract/document/5871597/},
	number = {2},
	urldate = {2024-04-04},
	journal = {IEEE Transactions on Parallel and Distributed Systems},
	author = {Desnoyers, Mathieu and McKenney, Paul E. and Stern, Alan S. and Dagenais, Michel R. and Walpole, Jonathan},
	year = {2011},
	note = {Publisher: IEEE},
	pages = {375--382},
	file = {Available Version (via Google Scholar):/home/wilson/Zotero/storage/B5XR7MMZ/Desnoyers et al. - 2011 - User-level implementations of read-copy update.pdf:application/pdf},
}

@article{crotty_are_2022,
	title = {Are {You} {Sure} {You} {Want} to {Use} {MMAP} in {Your} {Database} {Management} {System}?},
	abstract = {Memory-mapped (mmap) file I/O is an OS-provided feature that maps the contents of a file on secondary storage into a program’s address space. The program then accesses pages via pointers as if the file resided entirely in memory. The OS transparently loads pages only when the program references them and automatically evicts pages if memory fills up.},
	language = {en},
	author = {Crotty, Andrew and Leis, Viktor and Pavlo, Andrew},
	year = {2022},
	file = {Crotty et al. - 2022 - Are You Sure You Want to Use MMAP in Your Database.pdf:/home/wilson/Zotero/storage/HUMCZGHF/Crotty et al. - 2022 - Are You Sure You Want to Use MMAP in Your Database.pdf:application/pdf},
}
